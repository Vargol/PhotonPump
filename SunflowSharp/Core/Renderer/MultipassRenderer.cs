// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using SunflowSharp.Core.Bucket;
using SunflowSharp.Image;
using SunflowSharp.Maths;
using SunflowSharp.Systems;
using System.Threading;

namespace SunflowSharp.Core.Renderer
{
	public class MultipassRenderer : ImageSampler {

		private Scene scene;
		private IDisplay display;
		// resolution
		private int imageWidth;
		private int imageHeight;
		// bucketing
		private String bucketOrderName;
		private BucketOrder bucketOrder;
		private int bucketSize;
		private int bucketCounter;
		private int[] bucketCoords;
		
		// anti-aliasing
		private int numSamples;
		private float invNumSamples;
		private bool shadingCache;
		
		public MultipassRenderer() {
			bucketSize = 32;
			bucketOrderName = "hilbert";
			numSamples = 16;
			shadingCache = false;
		}
		
		public bool prepare(Options options, Scene scene, int w, int h) {
			this.scene = scene;
			imageWidth = w;
			imageHeight = h;
			
			// fetch options
			bucketSize = options.getInt("bucket.size", bucketSize);
			bucketOrderName = options.getstring("bucket.order", bucketOrderName);
			numSamples = options.getInt("aa.samples", numSamples);
			shadingCache = options.getbool("aa.cache", shadingCache);
			
			// limit bucket size and compute number of buckets in each direction
			bucketSize = MathUtils.clamp(bucketSize, 16, 512);
			int numBucketsX = (imageWidth + bucketSize - 1) / bucketSize;
			int numBucketsY = (imageHeight + bucketSize - 1) / bucketSize;
			bucketOrder = BucketOrderFactory.create(bucketOrderName);
			bucketCoords = bucketOrder.getBucketSequence(numBucketsX, numBucketsY);
			// validate AA options
			numSamples = Math.Max(1, numSamples);
			invNumSamples = 1.0f / numSamples;
			// prepare QMC sampling
			UI.printInfo(UI.Module.BCKT, "Multipass renderer settings:");
			UI.printInfo(UI.Module.BCKT, " * Resolution: {0}x{1}", imageWidth, imageHeight);
			UI.printInfo(UI.Module.BCKT, " * Bucket size: {0}", bucketSize);
			UI.printInfo(UI.Module.BCKT, " * Number of buckets: {0}x{1}", numBucketsX, numBucketsY);
			UI.printInfo(UI.Module.BCKT, " * Samples / pixel: {0}", numSamples);
			UI.printInfo(UI.Module.BCKT, " * Shading cache: {0}", shadingCache ? "enabled" : "disabled");
			return true;
		}
		
		public void render(IDisplay display) {
			this.display = display;
			display.imageBegin(imageWidth, imageHeight, bucketSize);
			// set members variables
			bucketCounter = 0;
			// start task
			Systems.Timer timer = new Systems.Timer();
			timer.start();
			UI.taskStart("Rendering", 0, bucketCoords.Length);
			BucketThread[] renderThreads = new BucketThread[scene.getThreads()];
			for (int i = 0; i < renderThreads.Length; i++) {
				renderThreads[i] = new BucketThread(i, this);
				renderThreads[i].setPriority(scene.getThreadPriority());
				renderThreads[i].start();
			}
			for (int i = 0; i < renderThreads.Length; i++) {
				try {
					renderThreads[i].join();
				} catch (Exception e) {
					UI.printError(UI.Module.BCKT, "Bucket processing thread {0} of {1} was interrupted", i + 1, renderThreads.Length);
				} finally {
					renderThreads[i].updateStats();
				}
			}
			UI.taskStop();
			timer.end();
			UI.printInfo(UI.Module.BCKT, "Render time: {0}", timer.ToString());
			display.imageEnd();
		}
		
		private class BucketThread  {
			private int threadID;
			private IntersectionState istate;
			private ShadingCache cache;
			// can not derive from Thread
			private Thread thread;
			// can not access fields in partents from nested classes
			MultipassRenderer renderer;
			
			public BucketThread(int threadID,  MultipassRenderer renderer) {
				this.threadID = threadID;
				istate = new IntersectionState();
				cache = renderer.shadingCache ? new ShadingCache() : null;
				this.renderer = renderer;
				thread = new Thread(new ThreadStart(run));
				thread.IsBackground = true;
				this.renderer = renderer;
			}
			
			public void run() {
				//ByteUtil.InitByteUtil();
				while (true) {
					int bx, by;
					lock (renderer) {
						if (renderer.bucketCounter >= renderer.bucketCoords.Length)
							return;
						UI.taskUpdate(renderer.bucketCounter);
						bx = renderer.bucketCoords[renderer.bucketCounter + 0];
						by = renderer.bucketCoords[renderer.bucketCounter + 1];
						renderer.bucketCounter += 2;
					}
					renderer.renderBucket(renderer.display, bx, by, threadID, istate, cache);
				}
			}

			public void setPriority(ThreadPriority prior)
			{
				thread.Priority = prior;
			}
			
			public void start()
			{
				thread.Start();
			}
			
			public void stop()
			{
				thread.Abort();
			}
			
			public void join()
			{
				thread.Join();
			}
			
			public void updateStats() {
				renderer.scene.accumulateStats(istate);
				if (renderer.shadingCache)
					renderer.scene.accumulateStats(cache);
			}
		}
		
		private void renderBucket(IDisplay display, int bx, int by, int threadID, IntersectionState istate, ShadingCache cache) {
			// pixel sized extents
			int x0 = bx * bucketSize;
			int y0 = by * bucketSize;
			int bw = Math.Min(bucketSize, imageWidth - x0);
			int bh = Math.Min(bucketSize, imageHeight - y0);
			
			// prepare bucket
			display.imagePrepare(x0, y0, bw, bh, threadID);
			
			Color[] bucketRGB = new Color[bw * bh];
			float[] bucketAlpha = new float[bw * bh];
			
			for (int y = 0, i = 0, cy = imageHeight - 1 - y0; y < bh; y++, cy--) {
				for (int x = 0, cx = x0; x < bw; x++, i++, cx++) {
					// sample pixel
					Color c = Color.black();
					float a = 0;
					int instance = ((cx & ((1 << QMC.MAX_SIGMA_ORDER) - 1)) << QMC.MAX_SIGMA_ORDER) + QMC.sigma(cy & ((1 << QMC.MAX_SIGMA_ORDER) - 1), QMC.MAX_SIGMA_ORDER);
					double jitterX = QMC.halton(0, instance);
					double jitterY = QMC.halton(1, instance);
					double jitterT = QMC.halton(2, instance);
					double jitterU = QMC.halton(3, instance);
					double jitterV = QMC.halton(4, instance);
					for (int s = 0; s < numSamples; s++) {
						float rx = cx + 0.5f + (float) warpCubic(QMC.mod1(jitterX + s * invNumSamples));
						float ry = cy + 0.5f + (float) warpCubic(QMC.mod1(jitterY + QMC.halton(0, s)));
						double time = QMC.mod1(jitterT + QMC.halton(1, s));
						double lensU = QMC.mod1(jitterU + QMC.halton(2, s));
						double lensV = QMC.mod1(jitterV + QMC.halton(3, s));
						ShadingState state = scene.getRadiance(istate, rx, ry, lensU, lensV, time, instance + s, 5, cache);
						if (state != null) {
							c.add(state.getResult());
							a++;
						}
					}
					bucketRGB[i] = c.mul(invNumSamples);
					bucketAlpha[i] = a * invNumSamples;
					if (cache != null)
						cache.reset();
				}
			}
			// update pixels
			display.imageUpdate(x0, y0, bw, bh, bucketRGB, bucketAlpha);
		}
		
		/**
		 * Tent filter warping function.
		 *
		 * @param x sample in the [0,1) range
		 * @return warped sample in the [-1,+1) range
		 */
		private static float warpTent(float x) {
			if (x < 0.5f)
				return -1 + (float) Math.Sqrt(2 * x);
			else
				return +1 - (float) Math.Sqrt(2 - 2 * x);
		}

		/**
		 * Cubic BSpline warping functions. Formulas from: "Generation of Stratified
		 * Samples for B-Spline Pixel Filtering"
		 * http://www.cs.utah.edu/~mstark/papers/
		 *
		 * @param x samples in the [0,1) range
		 * @return warped sample in the [-2,+2) range
		 */
		private static double warpCubic(double x) {
			if (x < (1.0 / 24))
				return qpow(24 * x) - 2;
			if (x < 0.5f)
				return distb1((24.0 / 11.0) * (x - (1.0 / 24.0))) - 1;
			if (x < (23.0f / 24))
				return 1 - distb1((24.0 / 11.0) * ((23.0 / 24.0) - x));
			return 2 - qpow(24 * (1 - x));
		}
		
		private static double qpow(double x) {
			return Math.Sqrt(Math.Sqrt(x));
		}
		
		private static double distb1(double x) {
			double u = x;
			for (int i = 0; i < 5; i++)
				u = (11 * x + u * u * (6 + u * (8 - 9 * u))) / (4 + 12 * u * (1 + u * (1 - u)));
			return u;
		}

	}
}

